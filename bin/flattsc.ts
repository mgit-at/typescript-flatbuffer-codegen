#!/usr/bin/env node
import * as process from 'process';
import * as fs from 'fs';
import * as path from 'path';
import * as execa from 'execa';
import * as yargs from 'yargs';

import * as fbR from '../src/reflection';

import {logAndExit, yargsOptions} from '../src/binHelper';
import {FbGenerator, Options} from '../src/fbGenerator';

const flatbuffersCompilerOptions = yargsOptions({
    'o': {
        type: 'string',
        description: 'Output all generated files to PATH'
    },
    'I': {
        type: 'string',
        description: 'when encountering include statements, attempt to load the files from this path. Paths will be tried in the order given, and if all fail (or none are specified) it will try to load relative to the path of the schema file being parsed.'
    },
    'proto': {
        type: 'boolean',
        description: 'Expect input files to be .proto files (protocol buffers). Output the corresponding .fbs file. Currently supports: package, message, enum, nested declarations, import (use -I for paths), extend, oneof, group. Does not support, but will skip without error: option, service, extensions, and most everything else.'
    },
    'oneof-union': {
        type: 'boolean',
        description: 'Translate .proto oneofs to flatbuffer unions.'
    },
    'conform': {
        type: 'string',
        description: 'Specify a schema the following schemas should be an evolution of. Gives errors if not. Useful to check if schema modifications don\'t break schema evolution rules.'
    },
    'conform-includes': {
        type: 'string',
        description: 'Include path for the schema given with --conform PATH.'
    },
});

const typescriptFlatbuffersCompilerOptions = yargsOptions({
    'build-parser': {
        type: 'boolean',
        description: 'Build the flatbuffers object parser',
        default: true
    },
    'build-objectify-func': {
        type: 'boolean',
        description: 'Build a objectify function for tables',
        default: true
    },
    'build-generator': {
        type: 'boolean',
        description: 'Build the flatbuffers object generator',
        default: true
    },
    'remove-tsc-files': {
        type: 'boolean',
        description: 'Remove files generated by the typescript compiler',
        default: true
    },
    'mkdir': {
        type: 'boolean',
        description: 'Create output directory',
        default: false
    }
});

const a = yargs
    .usage('[OPTIONS] FILES...')
    .version('0.0.1')
    .group(Object.keys(flatbuffersCompilerOptions), 'Flatbuffers compiler options')
    .options(flatbuffersCompilerOptions)
    .options({
        'filename-suffix': {
            type: 'string',
            description: 'The suffix appended to the generated file names. Default is \'_generated\'.',
            default: '_generated'
        },
    })
    .group(Object.keys(typescriptFlatbuffersCompilerOptions), 'Typescript flatbuffers compiler options')
    .options(typescriptFlatbuffersCompilerOptions)

    .argv
;

if (!a._.length) {
    logAndExit('no files specified');
}

let outputPath = process.cwd();
if (a.o) {
    outputPath = path.resolve(a.o);
}

let args: string[] = [
    '--binary',
    '--schema',
    '--gen-all',
    '-o', outputPath
];

if (a.I) {
    args.push(...['-I', a.I]);
}

if (a.proto) {
    args.push('--proto');
}

if (a['oneof-union']) {
    args.push('--oneof-union');
}

if (a.conform) {
    args.push(...['--conform', a.conform]);
}

if (a['conform-includes']) {
    args.push(...['--conform-includes', a['conform-includes']]);
}

const filesForFlatc = a._
    .map((f) => {
        if (typeof f !== 'string') {
            f = f.toString();
        }

        if (!fs.existsSync(f)) {
            logAndExit(`Invalid command or file ${f} not found`);
        }

        if (path.extname(f) === '.bfbs') {
            return '';
        }

        return f;
    })
    .filter((f) => !!f)
;

args.push(...filesForFlatc);

if (filesForFlatc.length) {
    const flatc = execa.sync('flatc', args);

    if (flatc.failed) {
        logAndExit(`flatc failed: ${flatc.stderr}`);
    }
}

const schemaFiles = a._.map((f) => {
    if (typeof f !== 'string') {
        f = f.toString();
    }

    if (path.extname(f) === '.bfbs') {
        return f;
    }

    let name = path.basename(f, path.extname(f)) + '.bfbs';

    return outputPath + path.sep + name;
});

if (a.mkdir) {
    fs.mkdirSync(outputPath, {recursive: true});
}

const tsFbOptions: Options = {
    buildFbParser: !!a['build-parser'],
    buildObjectifyFunc: !!a['build-objectify-func'],
    buildFbGenerator: !!a['build-generator']
};

const suffix = a['filename-suffix'];

schemaFiles.forEach((f) => {
    const content = fs.readFileSync(f);

    const r = fbR.Schema.fromFlatbuffer(content);

    const filename = path.join(
        outputPath,
        path.parse(f).name + suffix + '.ts'
    );

    const generator = new FbGenerator(r, tsFbOptions);
    const code = generator.generate(generator.filenameRequired() ? filename : undefined);

    if (!generator.filenameRequired()) {
        fs.writeFileSync(filename, code);
    }

    if (a['remove-tsc-files'] && filesForFlatc.includes(path.basename(f, '.bfbs') + '.fbs')) {
        fs.unlinkSync(f);
    }
});
