//automatically generated by the TypeScript FlatBuffers compiler, do not modify
import * as fblib from "../lib/fblib";
export enum BaseType {
    None = 0,
    UType = 1,
    Bool = 2,
    Byte = 3,
    UByte = 4,
    Short = 5,
    UShort = 6,
    Int = 7,
    UInt = 8,
    Long = 9,
    ULong = 10,
    Float = 11,
    Double = 12,
    String = 13,
    Vector = 14,
    Obj = 15,
    Union = 16,
    Array = 17,
    MaxBaseType = 18
}
export class Enum {
    __bb: fblib.ByteBuffer = new fblib.ByteBuffer(new Uint8Array());
    __bbPos: number = 0;
    name: string | null = null;
    values: EnumVal[] = [];
    isUnion: boolean = false;
    underlyingType: Type | null = null;
    attributes: KeyValue[] = [];
    documentation: string[] = [];
    static fromValues(name: string | null, values: EnumVal[], isUnion: boolean, underlyingType: Type | null, attributes: KeyValue[], documentation: string[]) {
        let __inst = new Enum();
        __inst.name = name;
        __inst.values = values;
        __inst.isUnion = isUnion;
        __inst.underlyingType = underlyingType;
        __inst.attributes = attributes;
        __inst.documentation = documentation;
        return __inst;
    }
    static fromZero(): Enum {
        return Enum.fromValues(null, [], false, null, [], []);
    }
    static __fbInit(__bb: fblib.ByteBuffer, __bbPos: number): Enum {
        let __inst: Enum;
        if ((__inst = __bb.offsetLookup.get(__bbPos))) {
            return __inst;
        }
        __inst = new Enum();
        __bb.offsetLookup.set(__bbPos, __inst);
        __inst.__bb = __bb;
        __inst.__bbPos = __bbPos;
        let _ofName = __bb.__offset(__bbPos, 4);
        __inst.name = _ofName ? __bb.__string(__bbPos + _ofName) : null;
        let _ofValues = __bb.__offset(__bbPos, 6);
        if (_ofValues) {
            let _lenValues = __bb.__vector_len(__bbPos + _ofValues);
            let _vecPosValues = __bb.__vector(__bbPos + _ofValues);
            __inst.values = new Array<EnumVal>(_lenValues);
            for (let __i = 0; __i < _lenValues; __i++) {
                __inst.values[__i] = EnumVal.__fbInit(__bb, __bb.__indirect(_vecPosValues + __i * 4));
            }
        }
        else {
            __inst.values = [];
        }
        let _ofIsUnion = __bb.__offset(__bbPos, 8);
        __inst.isUnion = _ofIsUnion ? !!__bb.readInt8(__bbPos + _ofIsUnion) : false;
        let _ofUnderlyingType = __bb.__offset(__bbPos, 10);
        __inst.underlyingType = _ofUnderlyingType ? Type.__fbInit(__bb, __bb.__indirect(__bbPos + _ofUnderlyingType)) : null;
        let _ofAttributes = __bb.__offset(__bbPos, 12);
        if (_ofAttributes) {
            let _lenAttributes = __bb.__vector_len(__bbPos + _ofAttributes);
            let _vecPosAttributes = __bb.__vector(__bbPos + _ofAttributes);
            __inst.attributes = new Array<KeyValue>(_lenAttributes);
            for (let __i = 0; __i < _lenAttributes; __i++) {
                __inst.attributes[__i] = KeyValue.__fbInit(__bb, __bb.__indirect(_vecPosAttributes + __i * 4));
            }
        }
        else {
            __inst.attributes = [];
        }
        let _ofDocumentation = __bb.__offset(__bbPos, 14);
        if (_ofDocumentation) {
            let _lenDocumentation = __bb.__vector_len(__bbPos + _ofDocumentation);
            let _vecPosDocumentation = __bb.__vector(__bbPos + _ofDocumentation);
            __inst.documentation = new Array<string>(_lenDocumentation);
            for (let __i = 0; __i < _lenDocumentation; __i++) {
                __inst.documentation[__i] = __bb.__string(_vecPosDocumentation + __i * 4);
            }
        }
        else {
            __inst.documentation = [];
        }
        return __inst;
    }
    static fromFlatbuffer(__buffer: Uint8Array, __continueLookup?: fblib.Table): Enum {
        let __bb = new fblib.ByteBuffer(__buffer);
        if (__continueLookup) {
            __bb.copyLookup(__continueLookup.__bb);
        }
        return Enum.__fbInit(__bb, __bb.readInt32(__bb.position()) + __bb.position());
    }
    copy(deepCopy: boolean = false): Enum {
        let __inst = new Enum();
        __inst.name = this.name;
        __inst.isUnion = this.isUnion;
        __inst.underlyingType = this.underlyingType ? this.underlyingType.copy() : null;
        if (deepCopy) {
            __inst.values = this.values.slice();
            __inst.attributes = this.attributes.slice();
            __inst.documentation = this.documentation.slice();
        }
        else {
            __inst.values = this.values;
            __inst.attributes = this.attributes;
            __inst.documentation = this.documentation;
        }
        return __inst;
    }
    objectify() {
        let values = new Array(this.values ? this.values.length : 0);
        let _values = this.values;
        if (this.values) {
            for (let __i = 0; __i < this.values.length; __i++) {
                values[__i] = this.values[__i].objectify();
            }
        }
        let attributes = new Array(this.attributes ? this.attributes.length : 0);
        let _attributes = this.attributes;
        if (this.attributes) {
            for (let __i = 0; __i < this.attributes.length; __i++) {
                attributes[__i] = this.attributes[__i].objectify();
            }
        }
        return {
            name: this.name,
            values: values,
            isUnion: this.isUnion,
            underlyingType: this.underlyingType ? this.underlyingType.objectify() : null,
            attributes: attributes,
            documentation: this.documentation
        };
    }
    buildJson() {
        return JSON.stringify(this.objectify());
    }
    __build(__builder: fblib.Builder) {
        let __offset: number;
        if ((__offset = __builder.registerObject(this))) {
            return __offset;
        }
        let _ofValues: number = 0;
        if (this.values instanceof Array && this.values.length) {
            let values: number[] = [];
            for (let __i = 0; __i < this.values.length; __i++) {
                values[__i] = this.values[__i].__build(__builder);
            }
            __builder.startVector(4, this.values.length, 4);
            for (let __i = this.values.length - 1; __i >= 0; __i--) {
                __builder.addOffsetObj(values[__i], this.values[__i]);
            }
            _ofValues = __builder.endVector();
        }
        let _ofAttributes: number = 0;
        if (this.attributes instanceof Array && this.attributes.length) {
            let attributes: number[] = [];
            for (let __i = 0; __i < this.attributes.length; __i++) {
                attributes[__i] = this.attributes[__i].__build(__builder);
            }
            __builder.startVector(4, this.attributes.length, 4);
            for (let __i = this.attributes.length - 1; __i >= 0; __i--) {
                __builder.addOffsetObj(attributes[__i], this.attributes[__i]);
            }
            _ofAttributes = __builder.endVector();
        }
        let _ofDocumentation: number = 0;
        if (this.documentation instanceof Array && this.documentation.length) {
            let documentation: number[] = [];
            for (let __i = 0; __i < this.documentation.length; __i++) {
                documentation[__i] = __builder.createString(this.documentation[__i]);
            }
            __builder.startVector(4, this.documentation.length, 4);
            for (let __i = this.documentation.length - 1; __i >= 0; __i--) {
                __builder.addOffsetString(documentation[__i]);
            }
            _ofDocumentation = __builder.endVector();
        }
        let _ofName: number = 0;
        if (typeof this.name === "string") {
            _ofName = __builder.createString(this.name);
        }
        let _ofUnderlyingType: number = 0;
        if (this.underlyingType) {
            _ofUnderlyingType = this.underlyingType.__build(__builder);
        }
        __builder.startObject(6, this);
        if (_ofName) {
            __builder.addFieldVector(0, _ofName, 0);
        }
        if (_ofValues) {
            __builder.addFieldVector(1, _ofValues, 0);
        }
        if (this.isUnion) {
            __builder.addFieldInt8(2, +this.isUnion, 0);
        }
        if (_ofUnderlyingType) {
            __builder.addFieldOffset(3, _ofUnderlyingType, this.underlyingType, 0);
        }
        if (_ofAttributes) {
            __builder.addFieldVector(4, _ofAttributes, 0);
        }
        if (_ofDocumentation) {
            __builder.addFieldVector(5, _ofDocumentation, 0);
        }
        return __builder.endObject();
    }
    buildFlatbuffer() {
        let __builder = new fblib.Builder();
        __builder.finish(this.__build(__builder));
        return __builder.bytes();
    }
}
export class EnumVal {
    __bb: fblib.ByteBuffer = new fblib.ByteBuffer(new Uint8Array());
    __bbPos: number = 0;
    name: string | null = null;
    value: number = 0;
    object: FbObject | null = null;
    unionType: Type | null = null;
    documentation: string[] = [];
    static fromValues(name: string | null, value: number, object: FbObject | null, unionType: Type | null, documentation: string[]) {
        let __inst = new EnumVal();
        __inst.name = name;
        __inst.value = value;
        __inst.object = object;
        __inst.unionType = unionType;
        __inst.documentation = documentation;
        return __inst;
    }
    static fromZero(): EnumVal {
        return EnumVal.fromValues(null, 0, null, null, []);
    }
    static __fbInit(__bb: fblib.ByteBuffer, __bbPos: number): EnumVal {
        let __inst: EnumVal;
        if ((__inst = __bb.offsetLookup.get(__bbPos))) {
            return __inst;
        }
        __inst = new EnumVal();
        __bb.offsetLookup.set(__bbPos, __inst);
        __inst.__bb = __bb;
        __inst.__bbPos = __bbPos;
        let _ofName = __bb.__offset(__bbPos, 4);
        __inst.name = _ofName ? __bb.__string(__bbPos + _ofName) : null;
        let _ofValue = __bb.__offset(__bbPos, 6);
        __inst.value = _ofValue ? __bb.readInt64(__bbPos + _ofValue) : 0;
        let _ofObject = __bb.__offset(__bbPos, 8);
        __inst.object = _ofObject ? FbObject.__fbInit(__bb, __bb.__indirect(__bbPos + _ofObject)) : null;
        let _ofUnionType = __bb.__offset(__bbPos, 10);
        __inst.unionType = _ofUnionType ? Type.__fbInit(__bb, __bb.__indirect(__bbPos + _ofUnionType)) : null;
        let _ofDocumentation = __bb.__offset(__bbPos, 12);
        if (_ofDocumentation) {
            let _lenDocumentation = __bb.__vector_len(__bbPos + _ofDocumentation);
            let _vecPosDocumentation = __bb.__vector(__bbPos + _ofDocumentation);
            __inst.documentation = new Array<string>(_lenDocumentation);
            for (let __i = 0; __i < _lenDocumentation; __i++) {
                __inst.documentation[__i] = __bb.__string(_vecPosDocumentation + __i * 4);
            }
        }
        else {
            __inst.documentation = [];
        }
        return __inst;
    }
    static fromFlatbuffer(__buffer: Uint8Array, __continueLookup?: fblib.Table): EnumVal {
        let __bb = new fblib.ByteBuffer(__buffer);
        if (__continueLookup) {
            __bb.copyLookup(__continueLookup.__bb);
        }
        return EnumVal.__fbInit(__bb, __bb.readInt32(__bb.position()) + __bb.position());
    }
    copy(deepCopy: boolean = false): EnumVal {
        let __inst = new EnumVal();
        __inst.name = this.name;
        __inst.value = this.value;
        __inst.unionType = this.unionType ? this.unionType.copy() : null;
        if (deepCopy) {
            __inst.object = this.object ? this.object.copy(true) : null;
            __inst.documentation = this.documentation.slice();
        }
        else {
            __inst.object = this.object ? this.object.copy() : null;
            __inst.documentation = this.documentation;
        }
        return __inst;
    }
    objectify() {
        return {
            name: this.name,
            value: this.value,
            object: this.object ? this.object.objectify() : null,
            unionType: this.unionType ? this.unionType.objectify() : null,
            documentation: this.documentation
        };
    }
    buildJson() {
        return JSON.stringify(this.objectify());
    }
    __build(__builder: fblib.Builder) {
        let __offset: number;
        if ((__offset = __builder.registerObject(this))) {
            return __offset;
        }
        let _ofDocumentation: number = 0;
        if (this.documentation instanceof Array && this.documentation.length) {
            let documentation: number[] = [];
            for (let __i = 0; __i < this.documentation.length; __i++) {
                documentation[__i] = __builder.createString(this.documentation[__i]);
            }
            __builder.startVector(4, this.documentation.length, 4);
            for (let __i = this.documentation.length - 1; __i >= 0; __i--) {
                __builder.addOffsetString(documentation[__i]);
            }
            _ofDocumentation = __builder.endVector();
        }
        let _ofName: number = 0;
        if (typeof this.name === "string") {
            _ofName = __builder.createString(this.name);
        }
        let _ofObject: number = 0;
        if (this.object) {
            _ofObject = this.object.__build(__builder);
        }
        let _ofUnionType: number = 0;
        if (this.unionType) {
            _ofUnionType = this.unionType.__build(__builder);
        }
        __builder.startObject(5, this);
        if (_ofName) {
            __builder.addFieldVector(0, _ofName, 0);
        }
        if (this.value) {
            __builder.addFieldInt64(1, this.value, 0);
        }
        if (_ofObject) {
            __builder.addFieldOffset(2, _ofObject, this.object, 0);
        }
        if (_ofUnionType) {
            __builder.addFieldOffset(3, _ofUnionType, this.unionType, 0);
        }
        if (_ofDocumentation) {
            __builder.addFieldVector(4, _ofDocumentation, 0);
        }
        return __builder.endObject();
    }
    buildFlatbuffer() {
        let __builder = new fblib.Builder();
        __builder.finish(this.__build(__builder));
        return __builder.bytes();
    }
}
export class FbObject {
    __bb: fblib.ByteBuffer = new fblib.ByteBuffer(new Uint8Array());
    __bbPos: number = 0;
    name: string | null = null;
    fields: Field[] = [];
    isStruct: boolean = false;
    minalign: number = 0;
    bytesize: number = 0;
    attributes: KeyValue[] = [];
    documentation: string[] = [];
    static fromValues(name: string | null, fields: Field[], isStruct: boolean, minalign: number, bytesize: number, attributes: KeyValue[], documentation: string[]) {
        let __inst = new FbObject();
        __inst.name = name;
        __inst.fields = fields;
        __inst.isStruct = isStruct;
        __inst.minalign = minalign;
        __inst.bytesize = bytesize;
        __inst.attributes = attributes;
        __inst.documentation = documentation;
        return __inst;
    }
    static fromZero(): FbObject {
        return FbObject.fromValues(null, [], false, 0, 0, [], []);
    }
    static __fbInit(__bb: fblib.ByteBuffer, __bbPos: number): FbObject {
        let __inst: FbObject;
        if ((__inst = __bb.offsetLookup.get(__bbPos))) {
            return __inst;
        }
        __inst = new FbObject();
        __bb.offsetLookup.set(__bbPos, __inst);
        __inst.__bb = __bb;
        __inst.__bbPos = __bbPos;
        let _ofName = __bb.__offset(__bbPos, 4);
        __inst.name = _ofName ? __bb.__string(__bbPos + _ofName) : null;
        let _ofFields = __bb.__offset(__bbPos, 6);
        if (_ofFields) {
            let _lenFields = __bb.__vector_len(__bbPos + _ofFields);
            let _vecPosFields = __bb.__vector(__bbPos + _ofFields);
            __inst.fields = new Array<Field>(_lenFields);
            for (let __i = 0; __i < _lenFields; __i++) {
                __inst.fields[__i] = Field.__fbInit(__bb, __bb.__indirect(_vecPosFields + __i * 4));
            }
        }
        else {
            __inst.fields = [];
        }
        let _ofIsStruct = __bb.__offset(__bbPos, 8);
        __inst.isStruct = _ofIsStruct ? !!__bb.readInt8(__bbPos + _ofIsStruct) : false;
        let _ofMinalign = __bb.__offset(__bbPos, 10);
        __inst.minalign = _ofMinalign ? __bb.readInt32(__bbPos + _ofMinalign) : 0;
        let _ofBytesize = __bb.__offset(__bbPos, 12);
        __inst.bytesize = _ofBytesize ? __bb.readInt32(__bbPos + _ofBytesize) : 0;
        let _ofAttributes = __bb.__offset(__bbPos, 14);
        if (_ofAttributes) {
            let _lenAttributes = __bb.__vector_len(__bbPos + _ofAttributes);
            let _vecPosAttributes = __bb.__vector(__bbPos + _ofAttributes);
            __inst.attributes = new Array<KeyValue>(_lenAttributes);
            for (let __i = 0; __i < _lenAttributes; __i++) {
                __inst.attributes[__i] = KeyValue.__fbInit(__bb, __bb.__indirect(_vecPosAttributes + __i * 4));
            }
        }
        else {
            __inst.attributes = [];
        }
        let _ofDocumentation = __bb.__offset(__bbPos, 16);
        if (_ofDocumentation) {
            let _lenDocumentation = __bb.__vector_len(__bbPos + _ofDocumentation);
            let _vecPosDocumentation = __bb.__vector(__bbPos + _ofDocumentation);
            __inst.documentation = new Array<string>(_lenDocumentation);
            for (let __i = 0; __i < _lenDocumentation; __i++) {
                __inst.documentation[__i] = __bb.__string(_vecPosDocumentation + __i * 4);
            }
        }
        else {
            __inst.documentation = [];
        }
        return __inst;
    }
    static fromFlatbuffer(__buffer: Uint8Array, __continueLookup?: fblib.Table): FbObject {
        let __bb = new fblib.ByteBuffer(__buffer);
        if (__continueLookup) {
            __bb.copyLookup(__continueLookup.__bb);
        }
        return FbObject.__fbInit(__bb, __bb.readInt32(__bb.position()) + __bb.position());
    }
    copy(deepCopy: boolean = false): FbObject {
        let __inst = new FbObject();
        __inst.name = this.name;
        __inst.isStruct = this.isStruct;
        __inst.minalign = this.minalign;
        __inst.bytesize = this.bytesize;
        if (deepCopy) {
            __inst.fields = this.fields.slice();
            __inst.attributes = this.attributes.slice();
            __inst.documentation = this.documentation.slice();
        }
        else {
            __inst.fields = this.fields;
            __inst.attributes = this.attributes;
            __inst.documentation = this.documentation;
        }
        return __inst;
    }
    objectify() {
        let fields = new Array(this.fields ? this.fields.length : 0);
        let _fields = this.fields;
        if (this.fields) {
            for (let __i = 0; __i < this.fields.length; __i++) {
                fields[__i] = this.fields[__i].objectify();
            }
        }
        let attributes = new Array(this.attributes ? this.attributes.length : 0);
        let _attributes = this.attributes;
        if (this.attributes) {
            for (let __i = 0; __i < this.attributes.length; __i++) {
                attributes[__i] = this.attributes[__i].objectify();
            }
        }
        return {
            name: this.name,
            fields: fields,
            isStruct: this.isStruct,
            minalign: this.minalign,
            bytesize: this.bytesize,
            attributes: attributes,
            documentation: this.documentation
        };
    }
    buildJson() {
        return JSON.stringify(this.objectify());
    }
    __build(__builder: fblib.Builder) {
        let __offset: number;
        if ((__offset = __builder.registerObject(this))) {
            return __offset;
        }
        let _ofFields: number = 0;
        if (this.fields instanceof Array && this.fields.length) {
            let fields: number[] = [];
            for (let __i = 0; __i < this.fields.length; __i++) {
                fields[__i] = this.fields[__i].__build(__builder);
            }
            __builder.startVector(4, this.fields.length, 4);
            for (let __i = this.fields.length - 1; __i >= 0; __i--) {
                __builder.addOffsetObj(fields[__i], this.fields[__i]);
            }
            _ofFields = __builder.endVector();
        }
        let _ofAttributes: number = 0;
        if (this.attributes instanceof Array && this.attributes.length) {
            let attributes: number[] = [];
            for (let __i = 0; __i < this.attributes.length; __i++) {
                attributes[__i] = this.attributes[__i].__build(__builder);
            }
            __builder.startVector(4, this.attributes.length, 4);
            for (let __i = this.attributes.length - 1; __i >= 0; __i--) {
                __builder.addOffsetObj(attributes[__i], this.attributes[__i]);
            }
            _ofAttributes = __builder.endVector();
        }
        let _ofDocumentation: number = 0;
        if (this.documentation instanceof Array && this.documentation.length) {
            let documentation: number[] = [];
            for (let __i = 0; __i < this.documentation.length; __i++) {
                documentation[__i] = __builder.createString(this.documentation[__i]);
            }
            __builder.startVector(4, this.documentation.length, 4);
            for (let __i = this.documentation.length - 1; __i >= 0; __i--) {
                __builder.addOffsetString(documentation[__i]);
            }
            _ofDocumentation = __builder.endVector();
        }
        let _ofName: number = 0;
        if (typeof this.name === "string") {
            _ofName = __builder.createString(this.name);
        }
        __builder.startObject(7, this);
        if (_ofName) {
            __builder.addFieldVector(0, _ofName, 0);
        }
        if (_ofFields) {
            __builder.addFieldVector(1, _ofFields, 0);
        }
        if (this.isStruct) {
            __builder.addFieldInt8(2, +this.isStruct, 0);
        }
        if (this.minalign) {
            __builder.addFieldInt32(3, this.minalign, 0);
        }
        if (this.bytesize) {
            __builder.addFieldInt32(4, this.bytesize, 0);
        }
        if (_ofAttributes) {
            __builder.addFieldVector(5, _ofAttributes, 0);
        }
        if (_ofDocumentation) {
            __builder.addFieldVector(6, _ofDocumentation, 0);
        }
        return __builder.endObject();
    }
    buildFlatbuffer() {
        let __builder = new fblib.Builder();
        __builder.finish(this.__build(__builder));
        return __builder.bytes();
    }
}
export class Field {
    __bb: fblib.ByteBuffer = new fblib.ByteBuffer(new Uint8Array());
    __bbPos: number = 0;
    name: string | null = null;
    type: Type | null = null;
    id: number = 0;
    offset: number = 0;
    defaultInteger: number = 0;
    defaultReal: number = 0;
    deprecated: boolean = false;
    required: boolean = false;
    key: boolean = false;
    attributes: KeyValue[] = [];
    documentation: string[] = [];
    static fromValues(name: string | null, type: Type | null, id: number, offset: number, defaultInteger: number, defaultReal: number, deprecated: boolean, required: boolean, key: boolean, attributes: KeyValue[], documentation: string[]) {
        let __inst = new Field();
        __inst.name = name;
        __inst.type = type;
        __inst.id = id;
        __inst.offset = offset;
        __inst.defaultInteger = defaultInteger;
        __inst.defaultReal = defaultReal;
        __inst.deprecated = deprecated;
        __inst.required = required;
        __inst.key = key;
        __inst.attributes = attributes;
        __inst.documentation = documentation;
        return __inst;
    }
    static fromZero(): Field {
        return Field.fromValues(null, null, 0, 0, 0, 0, false, false, false, [], []);
    }
    static __fbInit(__bb: fblib.ByteBuffer, __bbPos: number): Field {
        let __inst: Field;
        if ((__inst = __bb.offsetLookup.get(__bbPos))) {
            return __inst;
        }
        __inst = new Field();
        __bb.offsetLookup.set(__bbPos, __inst);
        __inst.__bb = __bb;
        __inst.__bbPos = __bbPos;
        let _ofName = __bb.__offset(__bbPos, 4);
        __inst.name = _ofName ? __bb.__string(__bbPos + _ofName) : null;
        let _ofType = __bb.__offset(__bbPos, 6);
        __inst.type = _ofType ? Type.__fbInit(__bb, __bb.__indirect(__bbPos + _ofType)) : null;
        let _ofId = __bb.__offset(__bbPos, 8);
        __inst.id = _ofId ? __bb.readUint16(__bbPos + _ofId) : 0;
        let _ofOffset = __bb.__offset(__bbPos, 10);
        __inst.offset = _ofOffset ? __bb.readUint16(__bbPos + _ofOffset) : 0;
        let _ofDefaultInteger = __bb.__offset(__bbPos, 12);
        __inst.defaultInteger = _ofDefaultInteger ? __bb.readInt64(__bbPos + _ofDefaultInteger) : 0;
        let _ofDefaultReal = __bb.__offset(__bbPos, 14);
        __inst.defaultReal = _ofDefaultReal ? __bb.readFloat64(__bbPos + _ofDefaultReal) : 0;
        let _ofDeprecated = __bb.__offset(__bbPos, 16);
        __inst.deprecated = _ofDeprecated ? !!__bb.readInt8(__bbPos + _ofDeprecated) : false;
        let _ofRequired = __bb.__offset(__bbPos, 18);
        __inst.required = _ofRequired ? !!__bb.readInt8(__bbPos + _ofRequired) : false;
        let _ofKey = __bb.__offset(__bbPos, 20);
        __inst.key = _ofKey ? !!__bb.readInt8(__bbPos + _ofKey) : false;
        let _ofAttributes = __bb.__offset(__bbPos, 22);
        if (_ofAttributes) {
            let _lenAttributes = __bb.__vector_len(__bbPos + _ofAttributes);
            let _vecPosAttributes = __bb.__vector(__bbPos + _ofAttributes);
            __inst.attributes = new Array<KeyValue>(_lenAttributes);
            for (let __i = 0; __i < _lenAttributes; __i++) {
                __inst.attributes[__i] = KeyValue.__fbInit(__bb, __bb.__indirect(_vecPosAttributes + __i * 4));
            }
        }
        else {
            __inst.attributes = [];
        }
        let _ofDocumentation = __bb.__offset(__bbPos, 24);
        if (_ofDocumentation) {
            let _lenDocumentation = __bb.__vector_len(__bbPos + _ofDocumentation);
            let _vecPosDocumentation = __bb.__vector(__bbPos + _ofDocumentation);
            __inst.documentation = new Array<string>(_lenDocumentation);
            for (let __i = 0; __i < _lenDocumentation; __i++) {
                __inst.documentation[__i] = __bb.__string(_vecPosDocumentation + __i * 4);
            }
        }
        else {
            __inst.documentation = [];
        }
        return __inst;
    }
    static fromFlatbuffer(__buffer: Uint8Array, __continueLookup?: fblib.Table): Field {
        let __bb = new fblib.ByteBuffer(__buffer);
        if (__continueLookup) {
            __bb.copyLookup(__continueLookup.__bb);
        }
        return Field.__fbInit(__bb, __bb.readInt32(__bb.position()) + __bb.position());
    }
    copy(deepCopy: boolean = false): Field {
        let __inst = new Field();
        __inst.name = this.name;
        __inst.type = this.type ? this.type.copy() : null;
        __inst.id = this.id;
        __inst.offset = this.offset;
        __inst.defaultInteger = this.defaultInteger;
        __inst.defaultReal = this.defaultReal;
        __inst.deprecated = this.deprecated;
        __inst.required = this.required;
        __inst.key = this.key;
        if (deepCopy) {
            __inst.attributes = this.attributes.slice();
            __inst.documentation = this.documentation.slice();
        }
        else {
            __inst.attributes = this.attributes;
            __inst.documentation = this.documentation;
        }
        return __inst;
    }
    objectify() {
        let attributes = new Array(this.attributes ? this.attributes.length : 0);
        let _attributes = this.attributes;
        if (this.attributes) {
            for (let __i = 0; __i < this.attributes.length; __i++) {
                attributes[__i] = this.attributes[__i].objectify();
            }
        }
        return {
            name: this.name,
            type: this.type ? this.type.objectify() : null,
            id: this.id,
            offset: this.offset,
            defaultInteger: this.defaultInteger,
            defaultReal: this.defaultReal,
            deprecated: this.deprecated,
            required: this.required,
            key: this.key,
            attributes: attributes,
            documentation: this.documentation
        };
    }
    buildJson() {
        return JSON.stringify(this.objectify());
    }
    __build(__builder: fblib.Builder) {
        let __offset: number;
        if ((__offset = __builder.registerObject(this))) {
            return __offset;
        }
        let _ofAttributes: number = 0;
        if (this.attributes instanceof Array && this.attributes.length) {
            let attributes: number[] = [];
            for (let __i = 0; __i < this.attributes.length; __i++) {
                attributes[__i] = this.attributes[__i].__build(__builder);
            }
            __builder.startVector(4, this.attributes.length, 4);
            for (let __i = this.attributes.length - 1; __i >= 0; __i--) {
                __builder.addOffsetObj(attributes[__i], this.attributes[__i]);
            }
            _ofAttributes = __builder.endVector();
        }
        let _ofDocumentation: number = 0;
        if (this.documentation instanceof Array && this.documentation.length) {
            let documentation: number[] = [];
            for (let __i = 0; __i < this.documentation.length; __i++) {
                documentation[__i] = __builder.createString(this.documentation[__i]);
            }
            __builder.startVector(4, this.documentation.length, 4);
            for (let __i = this.documentation.length - 1; __i >= 0; __i--) {
                __builder.addOffsetString(documentation[__i]);
            }
            _ofDocumentation = __builder.endVector();
        }
        let _ofName: number = 0;
        if (typeof this.name === "string") {
            _ofName = __builder.createString(this.name);
        }
        let _ofType: number = 0;
        if (this.type) {
            _ofType = this.type.__build(__builder);
        }
        __builder.startObject(11, this);
        if (_ofName) {
            __builder.addFieldVector(0, _ofName, 0);
        }
        if (_ofType) {
            __builder.addFieldOffset(1, _ofType, this.type, 0);
        }
        if (this.id) {
            __builder.addFieldUint16(2, this.id, 0);
        }
        if (this.offset) {
            __builder.addFieldUint16(3, this.offset, 0);
        }
        if (this.defaultInteger) {
            __builder.addFieldInt64(4, this.defaultInteger, 0);
        }
        if (this.defaultReal) {
            __builder.addFieldFloat64(5, this.defaultReal, 0);
        }
        if (this.deprecated) {
            __builder.addFieldInt8(6, +this.deprecated, 0);
        }
        if (this.required) {
            __builder.addFieldInt8(7, +this.required, 0);
        }
        if (this.key) {
            __builder.addFieldInt8(8, +this.key, 0);
        }
        if (_ofAttributes) {
            __builder.addFieldVector(9, _ofAttributes, 0);
        }
        if (_ofDocumentation) {
            __builder.addFieldVector(10, _ofDocumentation, 0);
        }
        return __builder.endObject();
    }
    buildFlatbuffer() {
        let __builder = new fblib.Builder();
        __builder.finish(this.__build(__builder));
        return __builder.bytes();
    }
}
export class KeyValue {
    __bb: fblib.ByteBuffer = new fblib.ByteBuffer(new Uint8Array());
    __bbPos: number = 0;
    key: string | null = null;
    value: string | null = null;
    static fromValues(key: string | null, value: string | null) {
        let __inst = new KeyValue();
        __inst.key = key;
        __inst.value = value;
        return __inst;
    }
    static fromZero(): KeyValue {
        return KeyValue.fromValues(null, null);
    }
    static __fbInit(__bb: fblib.ByteBuffer, __bbPos: number): KeyValue {
        let __inst: KeyValue;
        if ((__inst = __bb.offsetLookup.get(__bbPos))) {
            return __inst;
        }
        __inst = new KeyValue();
        __bb.offsetLookup.set(__bbPos, __inst);
        __inst.__bb = __bb;
        __inst.__bbPos = __bbPos;
        let _ofKey = __bb.__offset(__bbPos, 4);
        __inst.key = _ofKey ? __bb.__string(__bbPos + _ofKey) : null;
        let _ofValue = __bb.__offset(__bbPos, 6);
        __inst.value = _ofValue ? __bb.__string(__bbPos + _ofValue) : null;
        return __inst;
    }
    static fromFlatbuffer(__buffer: Uint8Array, __continueLookup?: fblib.Table): KeyValue {
        let __bb = new fblib.ByteBuffer(__buffer);
        if (__continueLookup) {
            __bb.copyLookup(__continueLookup.__bb);
        }
        return KeyValue.__fbInit(__bb, __bb.readInt32(__bb.position()) + __bb.position());
    }
    copy(): KeyValue {
        let __inst = new KeyValue();
        __inst.key = this.key;
        __inst.value = this.value;
        return __inst;
    }
    objectify() {
        return {
            key: this.key,
            value: this.value
        };
    }
    buildJson() {
        return JSON.stringify(this.objectify());
    }
    __build(__builder: fblib.Builder) {
        let __offset: number;
        if ((__offset = __builder.registerObject(this))) {
            return __offset;
        }
        let _ofKey: number = 0;
        if (typeof this.key === "string") {
            _ofKey = __builder.createString(this.key);
        }
        let _ofValue: number = 0;
        if (typeof this.value === "string") {
            _ofValue = __builder.createString(this.value);
        }
        __builder.startObject(2, this);
        if (_ofKey) {
            __builder.addFieldVector(0, _ofKey, 0);
        }
        if (_ofValue) {
            __builder.addFieldVector(1, _ofValue, 0);
        }
        return __builder.endObject();
    }
    buildFlatbuffer() {
        let __builder = new fblib.Builder();
        __builder.finish(this.__build(__builder));
        return __builder.bytes();
    }
}
export class RPCCall {
    __bb: fblib.ByteBuffer = new fblib.ByteBuffer(new Uint8Array());
    __bbPos: number = 0;
    name: string | null = null;
    request: FbObject | null = null;
    response: FbObject | null = null;
    attributes: KeyValue[] = [];
    documentation: string[] = [];
    static fromValues(name: string | null, request: FbObject | null, response: FbObject | null, attributes: KeyValue[], documentation: string[]) {
        let __inst = new RPCCall();
        __inst.name = name;
        __inst.request = request;
        __inst.response = response;
        __inst.attributes = attributes;
        __inst.documentation = documentation;
        return __inst;
    }
    static fromZero(): RPCCall {
        return RPCCall.fromValues(null, null, null, [], []);
    }
    static __fbInit(__bb: fblib.ByteBuffer, __bbPos: number): RPCCall {
        let __inst: RPCCall;
        if ((__inst = __bb.offsetLookup.get(__bbPos))) {
            return __inst;
        }
        __inst = new RPCCall();
        __bb.offsetLookup.set(__bbPos, __inst);
        __inst.__bb = __bb;
        __inst.__bbPos = __bbPos;
        let _ofName = __bb.__offset(__bbPos, 4);
        __inst.name = _ofName ? __bb.__string(__bbPos + _ofName) : null;
        let _ofRequest = __bb.__offset(__bbPos, 6);
        __inst.request = _ofRequest ? FbObject.__fbInit(__bb, __bb.__indirect(__bbPos + _ofRequest)) : null;
        let _ofResponse = __bb.__offset(__bbPos, 8);
        __inst.response = _ofResponse ? FbObject.__fbInit(__bb, __bb.__indirect(__bbPos + _ofResponse)) : null;
        let _ofAttributes = __bb.__offset(__bbPos, 10);
        if (_ofAttributes) {
            let _lenAttributes = __bb.__vector_len(__bbPos + _ofAttributes);
            let _vecPosAttributes = __bb.__vector(__bbPos + _ofAttributes);
            __inst.attributes = new Array<KeyValue>(_lenAttributes);
            for (let __i = 0; __i < _lenAttributes; __i++) {
                __inst.attributes[__i] = KeyValue.__fbInit(__bb, __bb.__indirect(_vecPosAttributes + __i * 4));
            }
        }
        else {
            __inst.attributes = [];
        }
        let _ofDocumentation = __bb.__offset(__bbPos, 12);
        if (_ofDocumentation) {
            let _lenDocumentation = __bb.__vector_len(__bbPos + _ofDocumentation);
            let _vecPosDocumentation = __bb.__vector(__bbPos + _ofDocumentation);
            __inst.documentation = new Array<string>(_lenDocumentation);
            for (let __i = 0; __i < _lenDocumentation; __i++) {
                __inst.documentation[__i] = __bb.__string(_vecPosDocumentation + __i * 4);
            }
        }
        else {
            __inst.documentation = [];
        }
        return __inst;
    }
    static fromFlatbuffer(__buffer: Uint8Array, __continueLookup?: fblib.Table): RPCCall {
        let __bb = new fblib.ByteBuffer(__buffer);
        if (__continueLookup) {
            __bb.copyLookup(__continueLookup.__bb);
        }
        return RPCCall.__fbInit(__bb, __bb.readInt32(__bb.position()) + __bb.position());
    }
    copy(deepCopy: boolean = false): RPCCall {
        let __inst = new RPCCall();
        __inst.name = this.name;
        if (deepCopy) {
            __inst.request = this.request ? this.request.copy(true) : null;
            __inst.response = this.response ? this.response.copy(true) : null;
            __inst.attributes = this.attributes.slice();
            __inst.documentation = this.documentation.slice();
        }
        else {
            __inst.request = this.request ? this.request.copy() : null;
            __inst.response = this.response ? this.response.copy() : null;
            __inst.attributes = this.attributes;
            __inst.documentation = this.documentation;
        }
        return __inst;
    }
    objectify() {
        let attributes = new Array(this.attributes ? this.attributes.length : 0);
        let _attributes = this.attributes;
        if (this.attributes) {
            for (let __i = 0; __i < this.attributes.length; __i++) {
                attributes[__i] = this.attributes[__i].objectify();
            }
        }
        return {
            name: this.name,
            request: this.request ? this.request.objectify() : null,
            response: this.response ? this.response.objectify() : null,
            attributes: attributes,
            documentation: this.documentation
        };
    }
    buildJson() {
        return JSON.stringify(this.objectify());
    }
    __build(__builder: fblib.Builder) {
        let __offset: number;
        if ((__offset = __builder.registerObject(this))) {
            return __offset;
        }
        let _ofAttributes: number = 0;
        if (this.attributes instanceof Array && this.attributes.length) {
            let attributes: number[] = [];
            for (let __i = 0; __i < this.attributes.length; __i++) {
                attributes[__i] = this.attributes[__i].__build(__builder);
            }
            __builder.startVector(4, this.attributes.length, 4);
            for (let __i = this.attributes.length - 1; __i >= 0; __i--) {
                __builder.addOffsetObj(attributes[__i], this.attributes[__i]);
            }
            _ofAttributes = __builder.endVector();
        }
        let _ofDocumentation: number = 0;
        if (this.documentation instanceof Array && this.documentation.length) {
            let documentation: number[] = [];
            for (let __i = 0; __i < this.documentation.length; __i++) {
                documentation[__i] = __builder.createString(this.documentation[__i]);
            }
            __builder.startVector(4, this.documentation.length, 4);
            for (let __i = this.documentation.length - 1; __i >= 0; __i--) {
                __builder.addOffsetString(documentation[__i]);
            }
            _ofDocumentation = __builder.endVector();
        }
        let _ofName: number = 0;
        if (typeof this.name === "string") {
            _ofName = __builder.createString(this.name);
        }
        let _ofRequest: number = 0;
        if (this.request) {
            _ofRequest = this.request.__build(__builder);
        }
        let _ofResponse: number = 0;
        if (this.response) {
            _ofResponse = this.response.__build(__builder);
        }
        __builder.startObject(5, this);
        if (_ofName) {
            __builder.addFieldVector(0, _ofName, 0);
        }
        if (_ofRequest) {
            __builder.addFieldOffset(1, _ofRequest, this.request, 0);
        }
        if (_ofResponse) {
            __builder.addFieldOffset(2, _ofResponse, this.response, 0);
        }
        if (_ofAttributes) {
            __builder.addFieldVector(3, _ofAttributes, 0);
        }
        if (_ofDocumentation) {
            __builder.addFieldVector(4, _ofDocumentation, 0);
        }
        return __builder.endObject();
    }
    buildFlatbuffer() {
        let __builder = new fblib.Builder();
        __builder.finish(this.__build(__builder));
        return __builder.bytes();
    }
}
export class Schema {
    __bb: fblib.ByteBuffer = new fblib.ByteBuffer(new Uint8Array());
    __bbPos: number = 0;
    objects: FbObject[] = [];
    enums: Enum[] = [];
    fileIdent: string | null = null;
    fileExt: string | null = null;
    rootTable: FbObject | null = null;
    services: Service[] = [];
    static fromValues(objects: FbObject[], enums: Enum[], fileIdent: string | null, fileExt: string | null, rootTable: FbObject | null, services: Service[]) {
        let __inst = new Schema();
        __inst.objects = objects;
        __inst.enums = enums;
        __inst.fileIdent = fileIdent;
        __inst.fileExt = fileExt;
        __inst.rootTable = rootTable;
        __inst.services = services;
        return __inst;
    }
    static fromZero(): Schema {
        return Schema.fromValues([], [], null, null, null, []);
    }
    static __fbInit(__bb: fblib.ByteBuffer, __bbPos: number): Schema {
        let __inst: Schema;
        if ((__inst = __bb.offsetLookup.get(__bbPos))) {
            return __inst;
        }
        __inst = new Schema();
        __bb.offsetLookup.set(__bbPos, __inst);
        __inst.__bb = __bb;
        __inst.__bbPos = __bbPos;
        let _ofObjects = __bb.__offset(__bbPos, 4);
        if (_ofObjects) {
            let _lenObjects = __bb.__vector_len(__bbPos + _ofObjects);
            let _vecPosObjects = __bb.__vector(__bbPos + _ofObjects);
            __inst.objects = new Array<FbObject>(_lenObjects);
            for (let __i = 0; __i < _lenObjects; __i++) {
                __inst.objects[__i] = FbObject.__fbInit(__bb, __bb.__indirect(_vecPosObjects + __i * 4));
            }
        }
        else {
            __inst.objects = [];
        }
        let _ofEnums = __bb.__offset(__bbPos, 6);
        if (_ofEnums) {
            let _lenEnums = __bb.__vector_len(__bbPos + _ofEnums);
            let _vecPosEnums = __bb.__vector(__bbPos + _ofEnums);
            __inst.enums = new Array<Enum>(_lenEnums);
            for (let __i = 0; __i < _lenEnums; __i++) {
                __inst.enums[__i] = Enum.__fbInit(__bb, __bb.__indirect(_vecPosEnums + __i * 4));
            }
        }
        else {
            __inst.enums = [];
        }
        let _ofFileIdent = __bb.__offset(__bbPos, 8);
        __inst.fileIdent = _ofFileIdent ? __bb.__string(__bbPos + _ofFileIdent) : null;
        let _ofFileExt = __bb.__offset(__bbPos, 10);
        __inst.fileExt = _ofFileExt ? __bb.__string(__bbPos + _ofFileExt) : null;
        let _ofRootTable = __bb.__offset(__bbPos, 12);
        __inst.rootTable = _ofRootTable ? FbObject.__fbInit(__bb, __bb.__indirect(__bbPos + _ofRootTable)) : null;
        let _ofServices = __bb.__offset(__bbPos, 14);
        if (_ofServices) {
            let _lenServices = __bb.__vector_len(__bbPos + _ofServices);
            let _vecPosServices = __bb.__vector(__bbPos + _ofServices);
            __inst.services = new Array<Service>(_lenServices);
            for (let __i = 0; __i < _lenServices; __i++) {
                __inst.services[__i] = Service.__fbInit(__bb, __bb.__indirect(_vecPosServices + __i * 4));
            }
        }
        else {
            __inst.services = [];
        }
        return __inst;
    }
    static fromFlatbuffer(__buffer: Uint8Array, __continueLookup?: fblib.Table): Schema {
        let __bb = new fblib.ByteBuffer(__buffer);
        if (__continueLookup) {
            __bb.copyLookup(__continueLookup.__bb);
        }
        return Schema.__fbInit(__bb, __bb.readInt32(__bb.position()) + __bb.position());
    }
    copy(deepCopy: boolean = false): Schema {
        let __inst = new Schema();
        __inst.fileIdent = this.fileIdent;
        __inst.fileExt = this.fileExt;
        if (deepCopy) {
            __inst.objects = this.objects.slice();
            __inst.enums = this.enums.slice();
            __inst.rootTable = this.rootTable ? this.rootTable.copy(true) : null;
            __inst.services = this.services.slice();
        }
        else {
            __inst.objects = this.objects;
            __inst.enums = this.enums;
            __inst.rootTable = this.rootTable ? this.rootTable.copy() : null;
            __inst.services = this.services;
        }
        return __inst;
    }
    objectify() {
        let objects = new Array(this.objects ? this.objects.length : 0);
        let _objects = this.objects;
        if (this.objects) {
            for (let __i = 0; __i < this.objects.length; __i++) {
                objects[__i] = this.objects[__i].objectify();
            }
        }
        let enums = new Array(this.enums ? this.enums.length : 0);
        let _enums = this.enums;
        if (this.enums) {
            for (let __i = 0; __i < this.enums.length; __i++) {
                enums[__i] = this.enums[__i].objectify();
            }
        }
        let services = new Array(this.services ? this.services.length : 0);
        let _services = this.services;
        if (this.services) {
            for (let __i = 0; __i < this.services.length; __i++) {
                services[__i] = this.services[__i].objectify();
            }
        }
        return {
            objects: objects,
            enums: enums,
            fileIdent: this.fileIdent,
            fileExt: this.fileExt,
            rootTable: this.rootTable ? this.rootTable.objectify() : null,
            services: services
        };
    }
    buildJson() {
        return JSON.stringify(this.objectify());
    }
    __build(__builder: fblib.Builder) {
        let __offset: number;
        if ((__offset = __builder.registerObject(this))) {
            return __offset;
        }
        let _ofObjects: number = 0;
        if (this.objects instanceof Array && this.objects.length) {
            let objects: number[] = [];
            for (let __i = 0; __i < this.objects.length; __i++) {
                objects[__i] = this.objects[__i].__build(__builder);
            }
            __builder.startVector(4, this.objects.length, 4);
            for (let __i = this.objects.length - 1; __i >= 0; __i--) {
                __builder.addOffsetObj(objects[__i], this.objects[__i]);
            }
            _ofObjects = __builder.endVector();
        }
        let _ofEnums: number = 0;
        if (this.enums instanceof Array && this.enums.length) {
            let enums: number[] = [];
            for (let __i = 0; __i < this.enums.length; __i++) {
                enums[__i] = this.enums[__i].__build(__builder);
            }
            __builder.startVector(4, this.enums.length, 4);
            for (let __i = this.enums.length - 1; __i >= 0; __i--) {
                __builder.addOffsetObj(enums[__i], this.enums[__i]);
            }
            _ofEnums = __builder.endVector();
        }
        let _ofServices: number = 0;
        if (this.services instanceof Array && this.services.length) {
            let services: number[] = [];
            for (let __i = 0; __i < this.services.length; __i++) {
                services[__i] = this.services[__i].__build(__builder);
            }
            __builder.startVector(4, this.services.length, 4);
            for (let __i = this.services.length - 1; __i >= 0; __i--) {
                __builder.addOffsetObj(services[__i], this.services[__i]);
            }
            _ofServices = __builder.endVector();
        }
        let _ofFileIdent: number = 0;
        if (typeof this.fileIdent === "string") {
            _ofFileIdent = __builder.createString(this.fileIdent);
        }
        let _ofFileExt: number = 0;
        if (typeof this.fileExt === "string") {
            _ofFileExt = __builder.createString(this.fileExt);
        }
        let _ofRootTable: number = 0;
        if (this.rootTable) {
            _ofRootTable = this.rootTable.__build(__builder);
        }
        __builder.startObject(6, this);
        if (_ofObjects) {
            __builder.addFieldVector(0, _ofObjects, 0);
        }
        if (_ofEnums) {
            __builder.addFieldVector(1, _ofEnums, 0);
        }
        if (_ofFileIdent) {
            __builder.addFieldVector(2, _ofFileIdent, 0);
        }
        if (_ofFileExt) {
            __builder.addFieldVector(3, _ofFileExt, 0);
        }
        if (_ofRootTable) {
            __builder.addFieldOffset(4, _ofRootTable, this.rootTable, 0);
        }
        if (_ofServices) {
            __builder.addFieldVector(5, _ofServices, 0);
        }
        return __builder.endObject();
    }
    buildFlatbuffer() {
        let __builder = new fblib.Builder();
        __builder.finish(this.__build(__builder));
        return __builder.bytes();
    }
}
export class Service {
    __bb: fblib.ByteBuffer = new fblib.ByteBuffer(new Uint8Array());
    __bbPos: number = 0;
    name: string | null = null;
    calls: RPCCall[] = [];
    attributes: KeyValue[] = [];
    documentation: string[] = [];
    static fromValues(name: string | null, calls: RPCCall[], attributes: KeyValue[], documentation: string[]) {
        let __inst = new Service();
        __inst.name = name;
        __inst.calls = calls;
        __inst.attributes = attributes;
        __inst.documentation = documentation;
        return __inst;
    }
    static fromZero(): Service {
        return Service.fromValues(null, [], [], []);
    }
    static __fbInit(__bb: fblib.ByteBuffer, __bbPos: number): Service {
        let __inst: Service;
        if ((__inst = __bb.offsetLookup.get(__bbPos))) {
            return __inst;
        }
        __inst = new Service();
        __bb.offsetLookup.set(__bbPos, __inst);
        __inst.__bb = __bb;
        __inst.__bbPos = __bbPos;
        let _ofName = __bb.__offset(__bbPos, 4);
        __inst.name = _ofName ? __bb.__string(__bbPos + _ofName) : null;
        let _ofCalls = __bb.__offset(__bbPos, 6);
        if (_ofCalls) {
            let _lenCalls = __bb.__vector_len(__bbPos + _ofCalls);
            let _vecPosCalls = __bb.__vector(__bbPos + _ofCalls);
            __inst.calls = new Array<RPCCall>(_lenCalls);
            for (let __i = 0; __i < _lenCalls; __i++) {
                __inst.calls[__i] = RPCCall.__fbInit(__bb, __bb.__indirect(_vecPosCalls + __i * 4));
            }
        }
        else {
            __inst.calls = [];
        }
        let _ofAttributes = __bb.__offset(__bbPos, 8);
        if (_ofAttributes) {
            let _lenAttributes = __bb.__vector_len(__bbPos + _ofAttributes);
            let _vecPosAttributes = __bb.__vector(__bbPos + _ofAttributes);
            __inst.attributes = new Array<KeyValue>(_lenAttributes);
            for (let __i = 0; __i < _lenAttributes; __i++) {
                __inst.attributes[__i] = KeyValue.__fbInit(__bb, __bb.__indirect(_vecPosAttributes + __i * 4));
            }
        }
        else {
            __inst.attributes = [];
        }
        let _ofDocumentation = __bb.__offset(__bbPos, 10);
        if (_ofDocumentation) {
            let _lenDocumentation = __bb.__vector_len(__bbPos + _ofDocumentation);
            let _vecPosDocumentation = __bb.__vector(__bbPos + _ofDocumentation);
            __inst.documentation = new Array<string>(_lenDocumentation);
            for (let __i = 0; __i < _lenDocumentation; __i++) {
                __inst.documentation[__i] = __bb.__string(_vecPosDocumentation + __i * 4);
            }
        }
        else {
            __inst.documentation = [];
        }
        return __inst;
    }
    static fromFlatbuffer(__buffer: Uint8Array, __continueLookup?: fblib.Table): Service {
        let __bb = new fblib.ByteBuffer(__buffer);
        if (__continueLookup) {
            __bb.copyLookup(__continueLookup.__bb);
        }
        return Service.__fbInit(__bb, __bb.readInt32(__bb.position()) + __bb.position());
    }
    copy(deepCopy: boolean = false): Service {
        let __inst = new Service();
        __inst.name = this.name;
        if (deepCopy) {
            __inst.calls = this.calls.slice();
            __inst.attributes = this.attributes.slice();
            __inst.documentation = this.documentation.slice();
        }
        else {
            __inst.calls = this.calls;
            __inst.attributes = this.attributes;
            __inst.documentation = this.documentation;
        }
        return __inst;
    }
    objectify() {
        let calls = new Array(this.calls ? this.calls.length : 0);
        let _calls = this.calls;
        if (this.calls) {
            for (let __i = 0; __i < this.calls.length; __i++) {
                calls[__i] = this.calls[__i].objectify();
            }
        }
        let attributes = new Array(this.attributes ? this.attributes.length : 0);
        let _attributes = this.attributes;
        if (this.attributes) {
            for (let __i = 0; __i < this.attributes.length; __i++) {
                attributes[__i] = this.attributes[__i].objectify();
            }
        }
        return {
            name: this.name,
            calls: calls,
            attributes: attributes,
            documentation: this.documentation
        };
    }
    buildJson() {
        return JSON.stringify(this.objectify());
    }
    __build(__builder: fblib.Builder) {
        let __offset: number;
        if ((__offset = __builder.registerObject(this))) {
            return __offset;
        }
        let _ofCalls: number = 0;
        if (this.calls instanceof Array && this.calls.length) {
            let calls: number[] = [];
            for (let __i = 0; __i < this.calls.length; __i++) {
                calls[__i] = this.calls[__i].__build(__builder);
            }
            __builder.startVector(4, this.calls.length, 4);
            for (let __i = this.calls.length - 1; __i >= 0; __i--) {
                __builder.addOffsetObj(calls[__i], this.calls[__i]);
            }
            _ofCalls = __builder.endVector();
        }
        let _ofAttributes: number = 0;
        if (this.attributes instanceof Array && this.attributes.length) {
            let attributes: number[] = [];
            for (let __i = 0; __i < this.attributes.length; __i++) {
                attributes[__i] = this.attributes[__i].__build(__builder);
            }
            __builder.startVector(4, this.attributes.length, 4);
            for (let __i = this.attributes.length - 1; __i >= 0; __i--) {
                __builder.addOffsetObj(attributes[__i], this.attributes[__i]);
            }
            _ofAttributes = __builder.endVector();
        }
        let _ofDocumentation: number = 0;
        if (this.documentation instanceof Array && this.documentation.length) {
            let documentation: number[] = [];
            for (let __i = 0; __i < this.documentation.length; __i++) {
                documentation[__i] = __builder.createString(this.documentation[__i]);
            }
            __builder.startVector(4, this.documentation.length, 4);
            for (let __i = this.documentation.length - 1; __i >= 0; __i--) {
                __builder.addOffsetString(documentation[__i]);
            }
            _ofDocumentation = __builder.endVector();
        }
        let _ofName: number = 0;
        if (typeof this.name === "string") {
            _ofName = __builder.createString(this.name);
        }
        __builder.startObject(4, this);
        if (_ofName) {
            __builder.addFieldVector(0, _ofName, 0);
        }
        if (_ofCalls) {
            __builder.addFieldVector(1, _ofCalls, 0);
        }
        if (_ofAttributes) {
            __builder.addFieldVector(2, _ofAttributes, 0);
        }
        if (_ofDocumentation) {
            __builder.addFieldVector(3, _ofDocumentation, 0);
        }
        return __builder.endObject();
    }
    buildFlatbuffer() {
        let __builder = new fblib.Builder();
        __builder.finish(this.__build(__builder));
        return __builder.bytes();
    }
}
export class Type {
    __bb: fblib.ByteBuffer = new fblib.ByteBuffer(new Uint8Array());
    __bbPos: number = 0;
    baseType: BaseType = BaseType.None;
    element: BaseType = BaseType.None;
    index: number = 0;
    fixedLength: number = 0;
    static fromValues(baseType: BaseType, element: BaseType, index: number, fixedLength: number) {
        let __inst = new Type();
        __inst.baseType = baseType;
        __inst.element = element;
        __inst.index = index;
        __inst.fixedLength = fixedLength;
        return __inst;
    }
    static fromZero(): Type {
        return Type.fromValues(0, 0, -1, 0);
    }
    static __fbInit(__bb: fblib.ByteBuffer, __bbPos: number): Type {
        let __inst: Type;
        if ((__inst = __bb.offsetLookup.get(__bbPos))) {
            return __inst;
        }
        __inst = new Type();
        __bb.offsetLookup.set(__bbPos, __inst);
        __inst.__bb = __bb;
        __inst.__bbPos = __bbPos;
        let _ofBaseType = __bb.__offset(__bbPos, 4);
        __inst.baseType = _ofBaseType ? __bb.readInt8(__bbPos + _ofBaseType) : 0;
        let _ofElement = __bb.__offset(__bbPos, 6);
        __inst.element = _ofElement ? __bb.readInt8(__bbPos + _ofElement) : 0;
        let _ofIndex = __bb.__offset(__bbPos, 8);
        __inst.index = _ofIndex ? __bb.readInt32(__bbPos + _ofIndex) : -1;
        let _ofFixedLength = __bb.__offset(__bbPos, 10);
        __inst.fixedLength = _ofFixedLength ? __bb.readUint16(__bbPos + _ofFixedLength) : 0;
        return __inst;
    }
    static fromFlatbuffer(__buffer: Uint8Array, __continueLookup?: fblib.Table): Type {
        let __bb = new fblib.ByteBuffer(__buffer);
        if (__continueLookup) {
            __bb.copyLookup(__continueLookup.__bb);
        }
        return Type.__fbInit(__bb, __bb.readInt32(__bb.position()) + __bb.position());
    }
    copy(): Type {
        let __inst = new Type();
        __inst.baseType = this.baseType;
        __inst.element = this.element;
        __inst.index = this.index;
        __inst.fixedLength = this.fixedLength;
        return __inst;
    }
    objectify() {
        return {
            baseType: this.baseType,
            element: this.element,
            index: this.index,
            fixedLength: this.fixedLength
        };
    }
    buildJson() {
        return JSON.stringify(this.objectify());
    }
    __build(__builder: fblib.Builder) {
        let __offset: number;
        if ((__offset = __builder.registerObject(this))) {
            return __offset;
        }
        __builder.startObject(4, this);
        if (this.baseType) {
            __builder.addFieldInt8(0, this.baseType, 0);
        }
        if (this.element) {
            __builder.addFieldInt8(1, this.element, 0);
        }
        if (this.index) {
            __builder.addFieldInt32(2, this.index, -1);
        }
        if (this.fixedLength) {
            __builder.addFieldUint16(3, this.fixedLength, 0);
        }
        return __builder.endObject();
    }
    buildFlatbuffer() {
        let __builder = new fblib.Builder();
        __builder.finish(this.__build(__builder));
        return __builder.bytes();
    }
}
