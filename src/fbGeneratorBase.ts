import * as fbR from './reflection';
import * as ts from 'typescript';
import {checkReserved} from './checkReserved';
import {
    createAnd, createArray,
    createBinary, createEqeqeq,
    createImportEverythingAs, createLeadingComment, createNestedPropertyAccess, createNullType,
    createQualifiedName, createTypeOf,
    createTypeReferenceNode, ensureExpression,
    StrExpression, StrIdentifier
} from './codegenHelper';
import {factory} from 'typescript';

export abstract class FbGeneratorBase {
    protected readonly sourceFile: ts.SourceFile;
    protected printer: ts.Printer;

    protected schema: fbR.Schema;

    protected hasProxy: boolean;
    protected hasString: boolean;

    protected nodes: ts.Node[] = [];

    protected readonly attributes = {
        proxy: 'proxy',
        numberAsLong: 'preserveLong',
        fieldAsRefIdentifier: 'uid',
    };

    protected readonly n = {
        clearLookupFunc: 'ClearLookup',
        clearLookupMemberFunc: 'clearLookup',
        lookupMember: '__lookup',

        fromZero: 'fromZero',
        fromValues: 'fromValues',
        fbInit: '__fbInit',
        fromFb: 'fromFlatbuffer',
        buildFb: 'buildFlatbuffer',
        fbBuild: '__build',
        objectify: 'objectify',
        buildJson: 'buildJson',

        copy: 'copy',
        deepCopy: 'deepCopy',

        instance: '__inst',
        proxyFeature: '__proxy',

        fbLibImport: 'fblib',
        fbLibLong: 'Long',
        fbLibByteBuffer: 'ByteBuffer',
        fbLibTable: 'Table',
        fbLibBuilder: 'Builder',
        fbLibArrayProxyHelper: 'ArrayProxyHelper',
        fbLibArrayProxyHelperDecodeAll: 'decodeAll',
        fbLibOffsetLookup: 'offsetLookup',
        fbLibRegisterObject: 'registerObject',
        fbLibReadType: (f: fbR.Field) => `read${this.convertTypeBuffer(f)}`,
        fbLibProxyDecodeAll: 'proxyDecodeAll',

        proxyVar: (v: string) => `_${v}`,
        proxyHelperVar: (v: string) => `_${v}ProxyHelper`,
        offsetVar: (v: string) => `_of${camelCase(v, true)}`,
        vecPosVar: (v: string) => `_vecPos${camelCase(v, true)}`,
        lengthVar: (v: string) => `_len${camelCase(v, true)}`,
        unionTypeVar: (v: string) => `${v}Type`,

        byteBuffer: '__bb',
        byteBufferPos: '__bbPos',
        continueLookup: '__continueLookup',

        counter1: '__i',
        builder: '__builder',
        finishObj: '__finishObj',
        instOffset: '__offset',
    };

    protected constructor(schema: fbR.Schema) {
        this.schema = schema;
        this.hasProxy = false;
        this.hasString = false;

        this.sourceFile = ts.createSourceFile(
            '',
            '',
            ts.ScriptTarget.Latest,
            false,
            ts.ScriptKind.TS
        );

        this.printer = ts.createPrinter({
            newLine: ts.NewLineKind.LineFeed
        });

        this.sanitizeSchema();
    }

    generate() {
        this.createImports();

        const print = this.generateInt();
        if (!print) {
            return '';
        }

        createLeadingComment(
            this.nodes[0],
            'automatically generated by the TypeScript FlatBuffers compiler, do not modify',
        );

        return this.printNodes();
    }

    protected abstract generateInt(): boolean;

    protected sanitizeSchema() {
        this.schema.objects.forEach((v) => {
            if (!checkReserved(getName(v))) {
                throw `Invalid name '${getName(v)}'`;
            }

            v.fields.forEach((f) => {
                f.name = camelCase(f.name!);

                if (!checkReserved(f.name)) {
                    throw `Invalid name '${f.name}'`;
                }

                if (f.type!.baseType === fbR.BaseType.String || f.type!.element === fbR.BaseType.String) {
                    this.hasString = true;
                }

                f.attributes.forEach((a) => {
                    if (a.key === this.attributes.proxy) {
                        this.hasProxy = true;
                    }
                });
            });
        });
    }

    protected printNodes() {
        return this.printer.printList(ts.ListFormat.MultiLine, factory.createNodeArray(this.nodes), this.sourceFile);
    }

    protected createImports() {
        this.nodes.push(createImportEverythingAs('@mgit-at/typescript-flatbuffers-codegen', this.n.fbLibImport));
    }

    protected convertType(f: fbR.Field, nullable: boolean = true): ts.TypeNode {
        if (f.type!.index >= 0 && !isArrayType(f.type!.baseType) && f.type!.baseType !== fbR.BaseType.Obj && f.type!.baseType !== fbR.BaseType.Union) {
            let obj = this.schema.enums[f.type!.index];
            return createTypeReferenceNode(getName(obj));
        }

        switch (f.type!.baseType) {
            case fbR.BaseType.None:
                return factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);

            case fbR.BaseType.Bool:
                return factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);

            case fbR.BaseType.Long:
            case fbR.BaseType.ULong:
                if (!!getAttributeInField(f, this.attributes.numberAsLong)) {
                    return createTypeReferenceNode(createQualifiedName(this.n.fbLibImport, this.n.fbLibLong));
                }

            // noinspection FallThroughInSwitchStatementJS
            case fbR.BaseType.UType:
            case fbR.BaseType.Byte:
            case fbR.BaseType.UByte:
            case fbR.BaseType.Short:
            case fbR.BaseType.UShort:
            case fbR.BaseType.Int:
            case fbR.BaseType.UInt:
            case fbR.BaseType.Float:
            case fbR.BaseType.Double:
                return factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);

            case fbR.BaseType.String:
                let strT: ts.TypeNode = factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);

                if (f.type!.element === fbR.BaseType.Vector || !nullable) {
                    return strT;
                }

                return factory.createUnionTypeNode([
                    strT,
                    createNullType()
                ]);

            case fbR.BaseType.Vector:
            case fbR.BaseType.Array:
                return factory.createArrayTypeNode(this.convertType(fieldStripArrayType(f)));

            case fbR.BaseType.Obj:
                let obj = this.schema.objects[f.type!.index];
                let t = createTypeReferenceNode(getName(obj));

                if (f.type!.element === fbR.BaseType.Vector || !nullable) {
                    return t;
                }

                return factory.createUnionTypeNode([
                    t,
                    createNullType()
                ]);

            case fbR.BaseType.Union:
                let en = this.schema.enums[f.type!.index];

                let types: ts.TypeNode[] = [];

                en.values.forEach((v) => {
                    if (v.value === 0) {
                        return;
                    }

                    types.push(createTypeReferenceNode(v.name!));
                });

                if (nullable) {
                    types.push(createNullType());
                }

                return factory.createUnionTypeNode(types);

            default:
                throw `Unknown type: ${f.type!.baseType}`;
        }
    }

    protected convertTypeToTypeCheck(f: fbR.Field, name?: StrExpression): ts.Expression {
        if (!name) {
            name = f.name!;
        }

        let t = '';

        switch (f.type!.baseType) {
            case fbR.BaseType.Bool:
                t = 'boolean';
                break;

            case fbR.BaseType.Long:
            case fbR.BaseType.ULong:
                if (!!getAttributeInField(f, this.attributes.numberAsLong)) {
                    return createBinary(
                        name,
                        ts.SyntaxKind.InstanceOfKeyword,
                        'Long'
                    );
                }

            // noinspection FallThroughInSwitchStatementJS
            case fbR.BaseType.UType:
            case fbR.BaseType.Byte:
            case fbR.BaseType.UByte:
            case fbR.BaseType.Short:
            case fbR.BaseType.UShort:
            case fbR.BaseType.Int:
            case fbR.BaseType.UInt:
            case fbR.BaseType.Float:
            case fbR.BaseType.Double:
                t = 'number';
                break;

            case fbR.BaseType.String:
                t = 'string';
                break;

            case fbR.BaseType.Vector:
            case fbR.BaseType.Array:
                return createAnd(
                    createBinary(
                        name,
                        ts.SyntaxKind.InstanceOfKeyword,
                        'Array'
                    ),
                    createNestedPropertyAccess(name, 'length')
                );

            case fbR.BaseType.Union:
            case fbR.BaseType.Obj:
                return ensureExpression(name);


            default:
                throw `Unknown type: ${f.type!.baseType}`;
        }

        return createEqeqeq(
            createTypeOf(name),
            factory.createStringLiteral(t)
        );
    }

    protected convertTypeBuffer(f: fbR.Field): string | null {
        if (f.type!.baseType === fbR.BaseType.Vector) {
            let fCopy = f.copy();
            fCopy.type = f.type!.copy();
            fCopy.type.baseType = fCopy.type.element;
            fCopy.type.element = -1;

            return this.convertTypeBuffer(fCopy);
        }

        switch (f.type!.baseType) {
            case fbR.BaseType.Bool:
            case fbR.BaseType.Byte:
                return 'Int8';

            case fbR.BaseType.UType:
            case fbR.BaseType.UByte:
                return 'Uint8';

            case fbR.BaseType.Short:
                return 'Int16';

            case fbR.BaseType.UShort:
                return 'Uint16';

            case fbR.BaseType.Int:
                return 'Int32';

            case fbR.BaseType.UInt:
                return 'Uint32';

            case fbR.BaseType.Long:
                if (!!getAttributeInField(f, this.attributes.numberAsLong)) {
                    return 'Int64AsLong';
                }

                return 'Int64';

            case fbR.BaseType.ULong:
                if (!!getAttributeInField(f, this.attributes.numberAsLong)) {
                    return 'Uint64AsLong';
                }

                return 'Uint64';

            case fbR.BaseType.Float:
                return 'Float32';

            case fbR.BaseType.Double:
                return 'Float64';
        }

        return null;
    }

    protected convertTypeToDefaultValue(f: fbR.Field) {
        switch (f.type!.baseType) {
            case fbR.BaseType.Bool:
                return f.defaultInteger ? factory.createTrue() : factory.createFalse();

            case fbR.BaseType.Long:
            case fbR.BaseType.ULong:
                if (!!getAttributeInField(f, this.attributes.numberAsLong)) {
                    //TODO: long default integer
                    // if (f.defaultInteger) {
                    //     return createNestedCall(
                    //         createNestedPropertyAccess(this.n.fbLibImport, this.n.fbLibLong),
                    //         ['create', []]
                    //     )
                    // }

                    return createNestedPropertyAccess(this.n.fbLibImport, this.n.fbLibLong, 'ZERO');
                }

            // noinspection FallThroughInSwitchStatementJS
            case fbR.BaseType.UType:
            case fbR.BaseType.Byte:
            case fbR.BaseType.UByte:
            case fbR.BaseType.Short:
            case fbR.BaseType.UShort:
            case fbR.BaseType.Int:
            case fbR.BaseType.UInt:
            case fbR.BaseType.Float:
            case fbR.BaseType.Double:
                return factory.createNumericLiteral(f.defaultInteger.toString());

            case fbR.BaseType.None:
            case fbR.BaseType.String:
            case fbR.BaseType.Union:
            case fbR.BaseType.Obj:
                return factory.createNull();

            case fbR.BaseType.Vector:
            case fbR.BaseType.Array:
                return createArray();

            default:
                throw `Unknown type: ${f.type!.baseType}`;
        }
    }

    protected containsClassOrArrayType(typeOrObject: fbR.Type | fbR.FbObject) {
        if (typeOrObject instanceof fbR.Type) {
            typeOrObject = typeStripArrayType(typeOrObject);

            if (typeOrObject.baseType !== fbR.BaseType.Obj) {
                return false;
            }

            typeOrObject = this.schema.objects[typeOrObject.index];
        }

        for (let i = 0; i < typeOrObject.fields.length; i++) {
            let f = typeOrObject.fields[i];
            if (isArrayType(f.type!.baseType) || f.type!.baseType === fbR.BaseType.Obj) {
                return true;
            }
        }

        return false;
    }

    protected typeInlineSize(type: fbR.Type): number {
        if (type.baseType === fbR.BaseType.Vector && type.element === fbR.BaseType.UByte) {
            debugger;
        }

        if (type.baseType === fbR.BaseType.Obj) {
            let obj = this.schema.objects[type.index];

            if (obj.isStruct) {
                return obj.bytesize;
            }
        }

        if (type.baseType === fbR.BaseType.Array) {
            return this.typeInlineSize(typeStripArrayType(type)) * type.fixedLength;
        }

        return sizeOfType(typeStripArrayType(type).baseType);
    }

    protected alignmentOfType(type: fbR.Type) {
        if (type.baseType === fbR.BaseType.Obj) {
            let obj = this.schema.objects[type.index];

            if (obj.isStruct) {
                return obj.minalign;
            }
        }

        if (type.baseType === fbR.BaseType.Array) {
            return this.typeInlineSize(typeStripArrayType(type)) * type.fixedLength;
        }

        return sizeOfType(type.baseType);
    }

    protected createInstanceVarNestedPropertyAccess(identifier1: StrIdentifier, ...identifier: StrIdentifier[]): ts.PropertyAccessExpression {
        return createNestedPropertyAccess(this.n.instance, identifier1, ...identifier);
    }

}

export function getName(name: string | fbR.FbObject | fbR.Enum): string {
    if (name instanceof fbR.FbObject || name instanceof fbR.Enum) {
        return getName(name.name!);
    }

    let parts = name.split('.');

    return camelCase(parts[parts.length - 1]);
}

export function camelCase(str: string, firstUpperCase: boolean = false): string {
    let parts = str.split('_');

    return parts.map((s, i) => {
        let f = s.charAt(0);

        if (i !== 0 || firstUpperCase) {
            f = f.toUpperCase();
        }

        return f + s.substring(1);
    }).join('');
}

export function getAttributeInField(f: fbR.Field, attribute: string) {
    for (let i1 = 0; i1 < f.attributes.length; i1++) {
        let a = f.attributes[i1];
        if (a.key === attribute) {
            return a.value!;
        }
    }

    return null;
}

export function getFbObjectUidField(v: fbR.FbObject) {
    for (let i = 0; i < v.fields.length; i++) {
        let f = v.fields[i];
        for (let i1 = 0; i1 < f.attributes.length; i1++) {
            let a = f.attributes[i1];
            if (a.key === 'uid') {
                return f;
            }
        }
    }

    return null;
}

export function typeStripArrayType(ft: fbR.Type): fbR.Type {
    let t = ft.copy();

    if (t.baseType !== fbR.BaseType.Vector && t.baseType !== fbR.BaseType.Array) {
        return t;
    }

    let e = t.element;
    t.element = t.baseType;
    t.baseType = e;

    return t;
}

export function fieldStripArrayType(f: fbR.Field): fbR.Field {
    let fC = f.copy();
    fC.type = typeStripArrayType(fC.type!);
    return fC;
}

export function sizeOfType(type: fbR.BaseType) {
    switch (type) {
        case fbR.BaseType.None:
        case fbR.BaseType.UType:
        case fbR.BaseType.Bool:
        case fbR.BaseType.Byte:
        case fbR.BaseType.UByte:
            return 1;

        case fbR.BaseType.Short:
        case fbR.BaseType.UShort:
            return 2;

        case fbR.BaseType.Int:
        case fbR.BaseType.UInt:
            return 4;

        case fbR.BaseType.Long:
        case fbR.BaseType.ULong:
            return 8;

        case fbR.BaseType.Float:
            return 4;

        case fbR.BaseType.Double:
            return 8;

        case fbR.BaseType.String:
        case fbR.BaseType.Vector:
        case fbR.BaseType.Obj:
        case fbR.BaseType.Union:
        case fbR.BaseType.Array:
            return 4;
    }

    throw 'Invalid type';
}

export function isArrayType(type: fbR.BaseType) {
    return type === fbR.BaseType.Array || type === fbR.BaseType.Vector;
}

export function isLongType(type: fbR.BaseType) {
    return type === fbR.BaseType.Long || type === fbR.BaseType.ULong;
}

export function isTypeScalar(type: fbR.Type) {
    return type.baseType >= fbR.BaseType.UType && type.baseType <= fbR.BaseType.Double;
}
